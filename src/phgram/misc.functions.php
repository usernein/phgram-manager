<?php
/**
 * Build an InlineKeyboardMarkup object, as JSON.
 *
 * @param array $options Array of lines. Each line is a array with buttons, that also are arrays. Check the documentation for examples.
 *
 * @return string
 */
function ikb(array $options, $encode = true) {
	$lines = [];
	foreach ($options as $line_pos => $line_buttons) {
		$lines[$line_pos] = [];
		foreach ($line_buttons as $button_pos => $button) {
			$lines[$line_pos][$button_pos] = btn(...$button);
		}
	}
	$replyMarkup = [
		'inline_keyboard' => $lines,
	];
	return ($encode? json_encode($replyMarkup, 480) : $replyMarkup);
}

/**
 * Build an InlineKeyboardButton object, as array.
 *
 * The type can be omitted. Passing two parameters (text and value), the type will be assumed as 'callback_data'.
 *
 * @param string $text Text to show in the button.
 * @param string $param Value which the button will use, depending of $type.
 * @param string $type Type of button. Optional. The default value is 'callback_data'.
 *
 * @return array
 */
function btn($text, string $value, string $type = 'callback_data') {
	return ['text' => $text, $type => $value];
}

 
/**
 * Build a ReplyKeyboardMarkup object, as JSON.
 * 
 * @param array $options Array of lines. Each line is a array with buttons, that can be arrays generated by kbtn() or strings. Check the documentation for examples.
 * @param boolean $resize_keyboard If TRUE, the keyboard will allow user's client to resize it. Optional. The default value is FALSE.
 * @param boolean $one_time_keyboard If TRUE, the keyboard will be closed after using a button. Optional. The default value is FALSE.
 * @param boolean $selective If TRUE, the keyboard will appear only to certain users. Optional. The default value is TRUE.
 *
 * @return string
 */
function kb(array $options, bool $resize_keyboard = FALSE, bool $one_time_keyboard = FALSE, bool $selective = TRUE) {
	$replyMarkup = [
		'keyboard' => $options,
		'resize_keyboard' => $resize_keyboard,
		'one_time_keyboard' => $one_time_keyboard,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, 480);
}

/**
 * Build a KeyboardButton object, as array.
 *
 * Is recommended to use only when you need to request contact or location.
 * If you need a simple text button, pass a string instead of KeyboardButton.
 *
 * @param string $text The button text.
 * @param boolean $request_contact Will the button ask for user's phone number? Optional. The default value is FALSE.
 * @param boolean $request_location Will the button ask for user's location? Optional. The default value is FALSE.
 * 
 * @return array
 */
function kbtn($text, bool $request_contact = FALSE, bool $request_location = FALSE) {
	$replyMarkup = [
		'text' => $text,
		'request_contact' => $request_contact,
		'request_location' => $request_location,
	];
	return $replyMarkup;
}

/**
 * Build a RepkyKeyboardRemove object, as JSON.
 *
 * @param boolean $selective If TRUE, the keyboard will disappear only for certain users. Optional. The default value is TRUE.
 *
 * @return string
 */
function hide_kb(bool $selective = TRUE) {
	$replyMarkup = [
		'remove_keyboard' => TRUE,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, 480);
}
 
/**
 * Build a ForceReply object, as JSON.
 *
 * @param boolean $selective If TRUE, the forceReply will affect only to certain users. Optional. The default value is TRUE.
 *
 * @return string
 */
function forceReply(bool $selective = TRUE) {
	$replyMarkup = [
		'force_reply' => TRUE,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, 480);
}

/**
 * Generate the source html text based on the entities
 */
function entities_to_html(string $text, array $entities = []) {
	$to16 = function($text) {
		return mb_convert_encoding($text, "UTF-16", "UTF-8"); //or utf-16le
	};
	$to8 = function($text) {
		return mb_convert_encoding($text, "UTF-8", "UTF-16"); //or utf-16le
	};
	$message_encode = $to16($text); //or utf-16le
	
	foreach (array_reverse($entities) as $entity) {
		$original = htmlspecialchars($to8(substr($message_encode, $entity['offset']*2, $entity['length']*2)));
		$url = isset($entity['url'])? htmlspecialchars($entity['url']) : '';
		$id = @$entity['user']['id'];
		
		switch ($entity['type']) {
			case 'bold':
				$message_encode = substr_replace($message_encode, $to16("<b>$original</b>"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'italic':
				$message_encode = substr_replace($message_encode, $to16("<i>$original</i>"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'code':
				$message_encode = substr_replace($message_encode, $to16("<code>$original</code>"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'pre':
				$message_encode = substr_replace($message_encode, $to16("<pre>$original</pre>"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'text_link':
				$message_encode = substr_replace($message_encode, $to16("<a href='{$url}'>$original</a>"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'text_mention':
				$message_encode = substr_replace($message_encode, $to16("<a href='tg://user?id={$id}'>$original</a>"), $entity['offset']*2, $entity['length']*2);
				break;
		}
	}
	
	$html = $to8($message_encode);
	return $html;
}
/**
 * Generate the source markdown text based on the entities
 */
function entities_to_markdown(string $text, array $entities = []) {
	$to16 = function($text) {
		return mb_convert_encoding($text, "UTF-16", "UTF-8"); //or utf-16le
	};
	$to8 = function($text) {
		return mb_convert_encoding($text, "UTF-8", "UTF-16"); //or utf-16le
	};
	$md_escape = function ($text) {
		return preg_replace('#([*`_\(\)\[\]])#', "\\\\\\1", $text);
	};
	$message_encode = $to16($text); //or utf-16le
	
	foreach (array_reverse($entities) as $entity) {
		$original = $md_escape($to8(substr($message_encode, $entity['offset']*2, $entity['length']*2)));
		$url = isset($entity['url'])? htmlspecialchars($entity['url']) : '';
		$id = @$entity['user']['id'];
		
		switch ($entity['type']) {
			case 'bold':
				$message_encode = substr_replace($message_encode, $to16("*$original*"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'italic':
				$message_encode = substr_replace($message_encode, $to16("_{$original}_"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'code':
				$message_encode = substr_replace($message_encode, $to16("`$original`"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'pre':
				$message_encode = substr_replace($message_encode, $to16("```$original```"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'text_link':
				$message_encode = substr_replace($message_encode, $to16("[$original]($url)"), $entity['offset']*2, $entity['length']*2);
				break;
			case 'text_mention':
				$message_encode = substr_replace($message_encode, $to16("[$original](tg://user?id={$id})"), $entity['offset']*2, $entity['length']*2);
				break;
		}
	}
	
	$md = $to8($message_encode);
	return $md;
}